"""
Django settings for kiaba project.

Generated by 'django-admin startproject' using Django 5.1.2.

This settings module is configured for:
- PostgreSQL (from environment variables)
- Redis cache
- Celery (broker + backend via Redis)
- django-allauth (limited signup will be enforced via a custom adapter later)
- Static/Media (FileSystem by default; S3 via env)
- i18n (fr default, en optional)
- Security headers (baseline)
"""

from pathlib import Path
import os
import sys
import logging

logger = logging.getLogger(__name__)

try:
    import environ  # type: ignore
except Exception:
    environ = None

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


if environ is not None:
    env = environ.Env(
        DEBUG=(bool, False),
        SECRET_KEY=(str, "change-me"),
        ALLOWED_HOSTS=(str, "localhost,127.0.0.1"),
        LANGUAGE_CODE=(str, "fr"),
        TIME_ZONE=(str, "Africa/Abidjan"),
        # Database
        DB_ENGINE=(str, "postgres"),  # 'postgres' or 'sqlite'
        POSTGRES_DB=(str, "kiaba"),
        POSTGRES_USER=(str, "kiaba"),
        POSTGRES_PASSWORD=(str, "kiaba"),
        POSTGRES_HOST=(str, "localhost"),
        POSTGRES_PORT=(int, 5432),
        # Redis
        REDIS_URL=(str, "redis://localhost:6379/1"),
        # Static/Media
        DEFAULT_FILE_STORAGE=(str, "django.core.files.storage.FileSystemStorage"),
        STATIC_URL=(str, "/static/"),
        STATIC_ROOT=(str, "staticfiles"),
        MEDIA_URL=(str, "/media/"),
        MEDIA_ROOT=(str, "media"),
        # Email (console backend pour d√©veloppement)
        EMAIL_BACKEND=(str, "django.core.mail.backends.console.EmailBackend"),
        DEFAULT_FROM_EMAIL=(str, "KIABA Rencontres <no-reply@example.com>"),
        SERVER_EMAIL=(str, "KIABA Rencontres Errors <errors@example.com>"),
        # CinetPay
        CINETPAY_SITE_ID=(str, ""),
        CINETPAY_API_KEY=(str, ""),
        CINETPAY_SITE_KEY=(str, ""),
        CINETPAY_NOTIFY_URL=(str, "https://ci-kiaba.com/accounts/payment/cinetpay/notify/"),
        CINETPAY_RETURN_URL=(str, "https://ci-kiaba.com/accounts/payment/cinetpay/return/"),
    )
    environ.Env.read_env(os.path.join(Path(__file__).resolve().parent.parent, ".env"))
else:

    class _DummyEnv:
        def __init__(self, **schema):
            self.schema = schema

        def __call__(self, key, default=None):
            if default is None and key in self.schema:
                default = self.schema[key][1]
            value = os.environ.get(key, default)
            return value

        def int(self, key, default=0):
            try:
                return int(os.environ.get(key, default))
            except Exception:
                return default

        def db(self, key, default=None):
            """Parse DATABASE_URL when django-environ is not available."""
            from urllib.parse import urlparse, unquote_plus

            url = os.environ.get(key, default)
            if not url:
                raise ValueError(f"{key} is not set")
            parsed = urlparse(url)
            path = parsed.path.lstrip("/") or "postgres"
            return {
                "ENGINE": "django.db.backends.postgresql",
                "NAME": path,
                "USER": unquote_plus(parsed.username) if parsed.username else "",
                "PASSWORD": unquote_plus(parsed.password) if parsed.password else "",
                "HOST": parsed.hostname or "",
                "PORT": str(parsed.port) if parsed.port else "5432",
            }

    env = _DummyEnv(
        DEBUG=(bool, False),
        SECRET_KEY=(str, "change-me"),
        ALLOWED_HOSTS=(str, "localhost,127.0.0.1"),
        LANGUAGE_CODE=(str, "fr"),
        TIME_ZONE=(str, "Africa/Abidjan"),
        DB_ENGINE=(str, "postgres"),
        POSTGRES_DB=(str, "kiaba"),
        POSTGRES_USER=(str, "kiaba"),
        POSTGRES_PASSWORD=(str, "kiaba"),
        POSTGRES_HOST=(str, "localhost"),
        POSTGRES_PORT=(int, 5432),
        REDIS_URL=(str, "redis://localhost:6379/1"),
        DEFAULT_FILE_STORAGE=(str, "django.core.files.storage.FileSystemStorage"),
        STATIC_URL=(str, "/static/"),
        STATIC_ROOT=(str, "staticfiles"),
        MEDIA_URL=(str, "/media/"),
        MEDIA_ROOT=(str, "media"),
        EMAIL_BACKEND=(str, "django.core.mail.backends.console.EmailBackend"),
        DEFAULT_FROM_EMAIL=(str, "KIABA Rencontres <no-reply@example.com>"),
        SERVER_EMAIL=(str, "KIABA Rencontres Errors <errors@example.com>"),
        # CinetPay
        CINETPAY_SITE_ID=(str, ""),
        CINETPAY_API_KEY=(str, ""),
        CINETPAY_SITE_KEY=(str, ""),
        CINETPAY_NOTIFY_URL=(str, "https://ci-kiaba.com/accounts/payment/cinetpay/notify/"),
        CINETPAY_RETURN_URL=(str, "https://ci-kiaba.com/accounts/payment/cinetpay/return/"),
    )

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env("SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!
# Convertir DEBUG correctement (les variables d'environnement sont des strings)
debug_val = env("DEBUG")
if isinstance(debug_val, str):
    DEBUG = debug_val.lower() in ("true", "1", "yes", "on")
else:
    DEBUG = bool(debug_val)

ALLOWED_HOSTS = [h.strip() for h in env("ALLOWED_HOSTS").split(",") if h.strip()]

# Add www version and Render external host automatically (uniquement en production)
if not DEBUG:
    ALLOWED_HOSTS.append("www.ci-kiaba.com")  # Pour accepter www avant redirection

# Add Render external host automatically if present
RENDER_EXTERNAL_URL = os.environ.get("RENDER_EXTERNAL_URL")
if RENDER_EXTERNAL_URL:
    try:
        from urllib.parse import urlparse

        _r = urlparse(RENDER_EXTERNAL_URL)
        if _r.hostname and _r.hostname not in ALLOWED_HOSTS:
            ALLOWED_HOSTS.append(_r.hostname)
    except Exception:
        pass

# Add Vercel host automatically if present
VERCEL_URL = os.environ.get("VERCEL_URL")
if VERCEL_URL and VERCEL_URL not in ALLOWED_HOSTS:
    ALLOWED_HOSTS.append(VERCEL_URL)
    ALLOWED_HOSTS.append(f".{VERCEL_URL}")  # Pour les sous-domaines *.vercel.app

# Application definition

INSTALLED_APPS = [
    # Django core
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.sites",
    "django.contrib.sitemaps",
    # "django.contrib.postgres",  # D√©sactiv√© pour SQLite local
    # Third-party
    "rest_framework",
    "django_htmx",
    "corsheaders",
    "imagekit",
    "storages",
    "allauth",
    "allauth.account",
    # Local apps
    "accounts.apps.AccountsConfig",
    "ads",
    "core",
    "moderation",
    "seo",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    # Compression gzip pour am√©liorer les performances
    "core.middleware.GZipCompressionMiddleware",
    # Cache agressif pour static / media (images d'annonces)
    "core.middleware.StaticMediaCacheMiddleware",
    # En dev on d√©sactive les redirections HTTP->HTTPS pour pouvoir utiliser http://127.0.0.1
    "core.middleware.RedirectMiddleware",  # Redirections HTTP->HTTPS et www->non-www (d√©sactiv√© si DEBUG=True, voir plus bas)
    "core.middleware.CloudflareMiddleware",  # R√©cup√®re l'IP r√©elle depuis Cloudflare (CF-Connecting-IP)
    "corsheaders.middleware.CorsMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "allauth.account.middleware.AccountMiddleware",
    "django_htmx.middleware.HtmxMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

# En d√©veloppement, on ne veut AUCUNE redirection automatique HTTP -> HTTPS
if DEBUG and "core.middleware.RedirectMiddleware" in MIDDLEWARE:
    MIDDLEWARE.remove("core.middleware.RedirectMiddleware")

ROOT_URLCONF = "kiaba.urls"

# Configuration des templates avec cache en production
_template_options = {
    "context_processors": [
        "django.template.context_processors.debug",
        "django.template.context_processors.request",
        "django.contrib.auth.context_processors.auth",
        "django.contrib.messages.context_processors.messages",
        "core.context_processors.site_metrics",
    ],
}

# En production, activer le cache de template pour am√©liorer les performances
if not DEBUG:
    _template_options["loaders"] = [
        (
            "django.template.loaders.cached.Loader",
            [
                "django.template.loaders.filesystem.Loader",
                "django.template.loaders.app_directories.Loader",
            ],
        )
    ]
    # APP_DIRS doit √™tre False quand loaders est d√©fini
    _template_app_dirs = False
else:
    # En DEBUG, utiliser APP_DIRS (plus simple pour le d√©veloppement)
    _template_app_dirs = True

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": _template_app_dirs,
        "OPTIONS": _template_options,
    },
]

WSGI_APPLICATION = "kiaba.wsgi.application"


# Database (PostgreSQL)
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

if "test" in sys.argv or env("DB_ENGINE") == "sqlite":
    # Utiliser SQLite pour tests/dev rapide
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }
else:
    # Configuration PostgreSQL avec SSL pour Render
    # V√©rifier d'abord si DATABASE_URL est fourni par Render (m√©thode recommand√©e)
    database_url = os.environ.get("DATABASE_URL")

    if database_url:
        # Vercel serverless : Supabase direct (db.xxx.supabase.co) est IPv6-only, √©choue avec "Cannot assign requested address"
        # Convertir automatiquement vers le pooler (IPv4 compatible) quand on est sur Vercel
        _vercel = os.environ.get("VERCEL") == "1"
        if _vercel and "db." in database_url and ".supabase.co" in database_url and "pooler.supabase.com" not in database_url:
            import re
            # Extraire project ref : db.PROJECT_REF.supabase.co
            _m = re.search(r"db\.([a-z0-9]+)\.supabase\.co", database_url)
            if _m:
                _ref = _m.group(1)
                _region = os.environ.get("SUPABASE_POOLER_REGION", "eu-central-1")
                _pooler_host = f"aws-0-{_region}.pooler.supabase.com"
                # Remplacer db.XXX.supabase.co par pooler host, et forcer port 6543
                database_url = re.sub(r"db\.[a-z0-9]+\.supabase\.co(:\d+)?", f"{_pooler_host}:6543", database_url)
                # User pooler : postgres.PROJECT_REF au lieu de postgres
                if f"postgres.{_ref}" not in database_url and "postgres:" in database_url:
                    database_url = database_url.replace("postgres:", f"postgres.{_ref}:", 1)
                os.environ["DATABASE_URL"] = database_url
                logger.info("üîÑ DATABASE_URL converti vers Supabase pooler (IPv4) pour Vercel")

        # Render fournit DATABASE_URL automatiquement quand on lie une base de donn√©es
        # Utiliser django-environ pour parser DATABASE_URL
        DATABASES = {"default": env.db("DATABASE_URL")}

        # S'assurer que sslmode=prefer est dans OPTIONS pour Render
        if "OPTIONS" not in DATABASES["default"]:
            DATABASES["default"]["OPTIONS"] = {}
        # Utiliser 'prefer' qui essaie SSL mais ne l'exige pas strictement
        # Cela √©vite les probl√®mes de validation de certificat
        DATABASES["default"]["OPTIONS"]["sslmode"] = "prefer"
        DATABASES["default"]["CONN_MAX_AGE"] = 0
        DATABASES["default"]["ATOMIC_REQUESTS"] = True
    else:
        # Fallback : utiliser les variables individuelles
        postgres_host = env("POSTGRES_HOST", default="")
        is_render_db = "render.com" in postgres_host.lower() or os.environ.get("RENDER_EXTERNAL_URL")
        is_supabase_db = "supabase.co" in postgres_host.lower()

        # Options de connexion de base
        db_options = {
            "connect_timeout": 10,
        }

        if is_render_db or is_supabase_db:
            # Sur Render, PostgreSQL exige SSL/TLS pour toutes les connexions
            # Utiliser 'prefer' qui essaie SSL mais ne l'exige pas strictement
            # Cela √©vite les probl√®mes de validation de certificat
            db_options["sslmode"] = "prefer"
            # D√©finir aussi les variables d'environnement pour psycopg2
            os.environ["PGSSLMODE"] = "prefer"
            # Ajouter connect_timeout pour √©viter les timeouts
            db_options["connect_timeout"] = 10

        DATABASES = {
            "default": {
                "ENGINE": "django.db.backends.postgresql",
                "NAME": env("POSTGRES_DB"),
                "USER": env("POSTGRES_USER"),
                "PASSWORD": env("POSTGRES_PASSWORD"),
                "HOST": postgres_host,
                "PORT": env("POSTGRES_PORT"),
                "OPTIONS": db_options,
                "CONN_MAX_AGE": 0,  # D√©sactiver le pooling pour √©viter les probl√®mes de connexion
                "ATOMIC_REQUESTS": True,
            }
        }


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = "fr"
LANGUAGES = [
    ("fr", "Fran√ßais"),
    ("en", "English"),
]

TIME_ZONE = env("TIME_ZONE")

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = env("STATIC_URL")
_static_root = env("STATIC_ROOT")
if not os.path.isabs(_static_root):
    STATIC_ROOT = BASE_DIR / _static_root
else:
    STATIC_ROOT = _static_root
STATICFILES_DIRS = [BASE_DIR / "static"]
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# WhiteNoise configuration for media files
WHITENOISE_USE_FINDERS = True
# En production, d√©sactiver AUTOREFRESH pour forcer la re-collection des fichiers statiques
WHITENOISE_AUTOREFRESH = DEBUG  # True en dev, False en prod
# Cache static files for 1 year (31536000 seconds)
# Note: Avec CompressedManifestStaticFilesStorage, les fichiers avec hash changent automatiquement
# mais le cache navigateur peut garder l'ancienne version. Pour forcer le refresh, on peut :
# 1. Vider le cache navigateur (Ctrl+Shift+R ou Cmd+Shift+R)
# 2. Utiliser un param√®tre de version dans l'URL (ex: ?v=2.0)
WHITENOISE_MAX_AGE = 31536000

# Media
MEDIA_URL = env("MEDIA_URL")
_media_root = env("MEDIA_ROOT")

# D√©tection de la plateforme de d√©ploiement
RENDER_EXTERNAL_URL = os.environ.get("RENDER_EXTERNAL_URL")
VERCEL = os.environ.get("VERCEL") == "1"
is_render = bool(RENDER_EXTERNAL_URL) or os.path.exists("/app/media")

# Configuration Media selon la plateforme
USE_SUPABASE_STORAGE = os.environ.get("USE_SUPABASE_STORAGE", "false").lower() in ("true", "1", "yes")

if VERCEL and USE_SUPABASE_STORAGE:
    # Vercel : stockage Supabase (S3-compatible, filesystem √©ph√©m√®re sur Vercel)
    DEFAULT_FILE_STORAGE = "storages.backends.s3boto3.S3Boto3Storage"
    AWS_ACCESS_KEY_ID = os.environ.get("SUPABASE_S3_ACCESS_KEY_ID") or os.environ.get("AWS_ACCESS_KEY_ID")
    AWS_SECRET_ACCESS_KEY = os.environ.get("SUPABASE_S3_SECRET_ACCESS_KEY") or os.environ.get("AWS_SECRET_ACCESS_KEY")
    AWS_STORAGE_BUCKET_NAME = os.environ.get("SUPABASE_STORAGE_BUCKET", "media")
    AWS_S3_ENDPOINT_URL = os.environ.get("SUPABASE_S3_ENDPOINT")
    AWS_S3_REGION_NAME = os.environ.get("AWS_REGION", "auto")
    AWS_S3_OBJECT_PARAMETERS = {"CacheControl": "max-age=31536000, public"}
    AWS_DEFAULT_ACL = "public-read"
    if os.environ.get("SUPABASE_STORAGE_PUBLIC_URL"):
        AWS_S3_CUSTOM_DOMAIN = os.environ.get("SUPABASE_STORAGE_PUBLIC_URL", "").replace("https://", "").replace("http://", "")
        MEDIA_URL = f"https://{AWS_S3_CUSTOM_DOMAIN}/{AWS_STORAGE_BUCKET_NAME}/"
    else:
        MEDIA_URL = os.environ.get("MEDIA_URL", f"{AWS_S3_ENDPOINT_URL or ''}/{AWS_STORAGE_BUCKET_NAME}/")
    MEDIA_ROOT = str(BASE_DIR / "media")
    logger.info("üìÅ Stockage m√©dia : Supabase (S3-compatible)")
elif is_render and not DEBUG:
    # Production sur Render : disque persistant
    MEDIA_ROOT = "/app/media"
    logger.info(f"üìÅ MEDIA_ROOT configur√© pour Render (disque persistant): {MEDIA_ROOT}")
    ads_dir = os.path.join(MEDIA_ROOT, "ads")
    os.makedirs(ads_dir, exist_ok=True)
elif not os.path.isabs(_media_root):
    # D√©veloppement local : utiliser le chemin relatif
    MEDIA_ROOT = BASE_DIR / _media_root
    logger.info(f"üìÅ MEDIA_ROOT configur√© pour d√©veloppement local: {MEDIA_ROOT}")
else:
    # Chemin absolu personnalis√©
    MEDIA_ROOT = _media_root
    logger.info(f"üìÅ MEDIA_ROOT configur√© (chemin absolu): {MEDIA_ROOT}")

# S'assurer que le dossier media existe (sauf sur Vercel/serverless, filesystem read-only)
if MEDIA_ROOT and not VERCEL and not USE_SUPABASE_STORAGE:
    os.makedirs(MEDIA_ROOT, exist_ok=True)
logger.info(f"üìÅ MEDIA_ROOT final: {MEDIA_ROOT}")

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# Sites framework
SITE_ID = 1
# En d√©veloppement, utiliser localhost:8080, sinon utiliser le domaine de production
if DEBUG:
    SITE_URL = env("SITE_URL", default="http://localhost:8080")
else:
    SITE_URL = env("SITE_URL", default="https://ci-kiaba.com")

# Caches (Forcer le cache local pour √©viter les erreurs Redis)
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": "unique-snowflake",
    }
}

# DRF (prepare throttling for rate limiting contact clicks)
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
    ],
    "DEFAULT_THROTTLE_CLASSES": [
        "rest_framework.throttling.AnonRateThrottle",
        "rest_framework.throttling.UserRateThrottle",
    ],
    "DEFAULT_THROTTLE_RATES": {
        "anon": "100/minute",
        "user": "300/minute",
    },
}

# CSRF / Security
_base_csrf = [
    "http://localhost:8080",
    "http://127.0.0.1:8080",
    "http://localhost:8000",
    "http://127.0.0.1:8000",
    "http://localhost:8001",
    "http://127.0.0.1:8001",
    # Domaine de production (requis pour l'inscription et les formulaires)
    "https://ci-kiaba.com",
    "https://www.ci-kiaba.com",
    "https://ci-kiaba.vercel.app",
]
_dynamic_csrf = []
try:
    from urllib.parse import urlparse as _urlparse

    if SITE_URL:
        _s = _urlparse(SITE_URL)
        if _s.scheme and _s.netloc:
            _dynamic_csrf.append(f"{_s.scheme}://{_s.netloc}")
    if RENDER_EXTERNAL_URL:
        _r = _urlparse(RENDER_EXTERNAL_URL)
        if _r.scheme and _r.netloc:
            _dynamic_csrf.append(f"{_r.scheme}://{_r.netloc}")
    if VERCEL_URL:
        _dynamic_csrf.append(f"https://{VERCEL_URL}")
        _dynamic_csrf.append(f"https://www.{VERCEL_URL}")
except Exception:
    pass
CSRF_TRUSTED_ORIGINS = _base_csrf + _dynamic_csrf
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_BROWSER_XSS_FILTER = True
X_FRAME_OPTIONS = "DENY"
# Configuration des cookies CSRF et Session
# En production (HTTPS), activer Secure pour les cookies
# En d√©veloppement (HTTP), d√©sactiver Secure pour permettre les cookies locaux
SESSION_COOKIE_SECURE = not DEBUG
CSRF_COOKIE_SECURE = not DEBUG
# Renforcer la protection des cookies en toutes circonstances
SESSION_COOKIE_HTTPONLY = True
CSRF_COOKIE_HTTPONLY = True
# SameSite pour les cookies CSRF : 'Lax' permet les requ√™tes GET cross-site mais bloque les POST malveillants
# 'Lax' est un bon compromis entre s√©curit√© et fonctionnalit√©
CSRF_COOKIE_SAMESITE = 'Lax'
SESSION_COOKIE_SAMESITE = 'Lax'
# Domaine des cookies : None pour que chaque host (www, non-www, vercel.app) ait son propre cookie.
# .ci-kiaba.com cassait www et vercel.app car le navigateur rejette un cookie Domain=.ci-kiaba.com
# quand la r√©ponse vient de ci-kiaba.vercel.app (pas un sous-domaine).
CSRF_COOKIE_DOMAIN = None
SESSION_COOKIE_DOMAIN = None
# Dur√©e des sessions (14 jours)
SESSION_COOKIE_AGE = 60 * 60 * 24 * 14
SESSION_SAVE_EVERY_REQUEST = False
SESSION_EXPIRE_AT_BROWSER_CLOSE = False
# Politique de referrer : strict-origin-when-cross-origin permet d'envoyer Referer/Origin
# pour les requ√™tes cross-origin (n√©cessaire pour CSRF avec www/non-www et proxies)
# "same-origin" √©tait trop stricte et bloquait la v√©rification CSRF dans certains cas
SECURE_REFERRER_POLICY = "strict-origin-when-cross-origin"
# D√©sactiver compl√®tement HSTS en d√©veloppement pour √©viter les redirections HTTPS forc√©es
SECURE_HSTS_SECONDS = 0  # Toujours 0 pour permettre HTTP en local
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
# Configuration HTTPS pour les proxies (Render, etc.)
# Render passe le header X-Forwarded-Proto pour indiquer HTTPS
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
# Forcer Django √† consid√©rer les requ√™tes comme s√©curis√©es si le proxy indique HTTPS
USE_TLS = not DEBUG

# CORS (if needed for future API)
CORS_ALLOW_ALL_ORIGINS = DEBUG

"""
Email configuration - SMTP
- En dev : backend console par d√©faut (ou SMTP si configur√©)
- En prod : SMTP configur√© via variables d'environnement (LWS, Brevo, SendGrid, etc.)
"""

EMAIL_BACKEND = env(
    "EMAIL_BACKEND",
    default="django.core.mail.backends.console.EmailBackend",
)

# Identit√© d'envoi
DEFAULT_FROM_EMAIL = env(
    "DEFAULT_FROM_EMAIL",
    default="KIABA Rencontres <no-replay@ci-kiaba.com>",
)
SERVER_EMAIL = env(
    "SERVER_EMAIL",
    default="KIABA Rencontres Errors <no-replay@ci-kiaba.com>",
)

# Param√®tres SMTP (LWS, Brevo, SendGrid, etc.)
# Configuration via variables d'environnement
EMAIL_HOST = env("EMAIL_HOST", default="")
EMAIL_PORT = env.int("EMAIL_PORT", default=587)
EMAIL_HOST_USER = env("EMAIL_HOST_USER", default="")
EMAIL_HOST_PASSWORD = env("EMAIL_HOST_PASSWORD", default="")

# SendGrid HTTP API key (recommand√© pour Render, √©vite les blocages SMTP)
# Si EMAIL_HOST_PASSWORD contient une cl√© SendGrid (commence par SG.), elle sera utilis√©e automatiquement
SENDGRID_API_KEY = env("SENDGRID_API_KEY", default="")

# SSL/TLS : g√©n√©ralement 587+TLS ou 465+SSL
# Par d√©faut, on utilise 587+TLS (plus standard)
EMAIL_USE_SSL = env("EMAIL_USE_SSL", default="False").lower() in ("true", "1", "yes")
EMAIL_USE_TLS = env("EMAIL_USE_TLS", default="True").lower() in ("true", "1", "yes")

EMAIL_TIMEOUT = env.int("EMAIL_TIMEOUT", default=10)  # Timeout pour SMTP
EMAIL_USE_LOCALTIME = True
EMAIL_SUBJECT_PREFIX = "[KIABA] "
EMAIL_USE_8BIT = False
EMAIL_CHARSET = "utf-8"

# En d√©veloppement local, utiliser console backend par d√©faut
# Pour tester SMTP en local, configure les variables d'environnement
if DEBUG and not EMAIL_HOST:
    EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"
elif EMAIL_HOST:
    # Si EMAIL_HOST est configur√©, utiliser SMTP
    EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"

# Storage
DEFAULT_FILE_STORAGE = env("DEFAULT_FILE_STORAGE")

# Google Analytics
GA_MEASUREMENT_ID = env("GA_MEASUREMENT_ID", default=None)

# Google AdSense
ADSENSE_PUBLISHER_ID = env(
    "ADSENSE_PUBLISHER_ID", default="ca-pub-3273662002214639"
)  # Format: ca-pub-XXXXXXXXXX
ADSENSE_ENABLED = env("ADSENSE_ENABLED", default="True").lower() in ("true", "1", "yes")

# Celery (broker/backend via Redis ou base de donn√©es)
REDIS_URL = env("REDIS_URL", default=None)
if REDIS_URL and REDIS_URL.strip():
    CELERY_BROKER_URL = REDIS_URL
    CELERY_RESULT_BACKEND = REDIS_URL
    CELERY_TASK_ALWAYS_EAGER = False  # Utiliser Celery avec Redis
else:
    # Fallback memory (√©vite le warning Kombu "No hostname was supplied")
    CELERY_BROKER_URL = "memory://localhost/"
    CELERY_RESULT_BACKEND = "cache+memory://"
    # En production sans Redis, ex√©cuter les t√¢ches Celery en mode synchrone
    CELERY_TASK_ALWAYS_EAGER = True  # Mode synchrone si pas de Redis

CELERY_TIMEZONE = TIME_ZONE
CELERY_TASK_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_BEAT_SCHEDULE = {
    "expire-ads-daily": {
        "task": "ads.tasks.expire_ads",
        "schedule": 60 * 60 * 24,  # quotidien
    }
}

# Sitemaps
SITEMAP_PROTOCOL = "https"

# Authentication backends (allauth + Django)
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "allauth.account.auth_backends.AuthenticationBackend",
)

# allauth basic settings (we'll restrict provider signups later via adapter/forms)
ACCOUNT_AUTHENTICATION_METHOD = "username_email"
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_EMAIL_VERIFICATION = "mandatory"  # Obligatoire pour valider les comptes
LOGIN_REDIRECT_URL = "/dashboard"
LOGIN_URL = "/auth/login/"
ACCOUNT_LOGOUT_REDIRECT_URL = "/"
LOGOUT_REDIRECT_URL = "/"
ACCOUNT_EMAIL_CONFIRMATION_AUTO_LOGIN = True
ACCOUNT_EMAIL_CONFIRMATION_ANONYMOUS_REDIRECT_URL = "/auth/login/"
ACCOUNT_EMAIL_CONFIRMATION_AUTHENTICATED_REDIRECT_URL = "/dashboard/"

# Rate limiting allauth pour limiter les tentatives de bruteforce & abus
# (utilise le cache Django ; ici LocMem en production sans Redis)
ACCOUNT_RATE_LIMITS = {
    "login_failed": "5/5m",  # max 5 √©checs de login / 5 minutes par IP+user
    "signup": "3/h",  # max 3 inscriptions / heure
    "reset_password": "3/h",  # max 3 demandes de reset / heure
}

# D√©sactiver la page de confirmation de d√©connexion
ACCOUNT_LOGOUT_ON_GET = True

# Utiliser l'adaptateur personnalis√©
ACCOUNT_ADAPTER = "accounts.adapters.NoRateLimitAccountAdapter"

# Utiliser les formulaires personnalis√©s
ACCOUNT_FORMS = {
    "login": "accounts.forms.CustomLoginForm",
    "signup": "accounts.forms.CustomSignupForm",
}

# Custom user model
AUTH_USER_MODEL = "accounts.CustomUser"

# CinetPay configuration
CINETPAY_SITE_ID = env("CINETPAY_SITE_ID", default="")
CINETPAY_API_KEY = env("CINETPAY_API_KEY", default="")
CINETPAY_SITE_KEY = env("CINETPAY_SITE_KEY", default="")
CINETPAY_MODE = env("CINETPAY_MODE", default="PRODUCTION")  # PRODUCTION ou TEST
CINETPAY_NOTIFY_URL = env(
    "CINETPAY_NOTIFY_URL", default="https://ci-kiaba.com/accounts/payment/cinetpay/notify/"
)
CINETPAY_RETURN_URL = env(
    "CINETPAY_RETURN_URL", default="https://ci-kiaba.com/accounts/payment/cinetpay/return/"
)
